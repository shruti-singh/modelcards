{"paragraphs": ["SpanBERT: Improving Pre-training by Representing and Predicting Spans. We present SpanBERT, a pre-training method that is designed to better represent and predict spans of text. Our approach extends BERT by (1) masking contiguous random spans, rather than random tokens, and (2) training the span boundary representations to predict the entire content of the masked span, without relying on the individual token representations within it. SpanBERT consistently outperforms BERT and our better-tuned baselines, with substantial gains on span selection tasks such as question answering and coreference resolution. In particular, with the same training data and model size as BERTlarge, our single model obtains 94.6% and 88.7% F1 on SQuAD 1.1 and 2.0 respectively. We also achieve a new state of the art on the OntoNotes coreference resolution task (79.6% F1), strong performance on the TACRED relation extraction benchmark, and even gains on GLUE.1 SpanBERT: Improving Pre-training by Representing and Predicting Spans. We present SpanBERT, a pre-training method that is designed to better represent and predict spans of text. Our approach extends BERT by (1) masking contiguous random spans, rather than random tokens, and (2) training the span boundary representations to predict the entire content of the masked span, without relying on the individual token representations within it. SpanBERT consistently outperforms BERT and our better-tuned baselines, with substantial gains on span selection tasks such as question answering and coreference resolution. In particular, with the same training data and model size as BERTlarge, our single model obtains 94.6% and 88.7% F1 on SQuAD 1.1 and 2.0 respectively. We also achieve a new state of the art on the OntoNotes coreference resolution task (79.6% F1), strong performance on the TACRED relation extraction benchmark, and even gains on GLUE.1\n1 Introduction.", "Pre-training methods like BERT (Devlin et al., 2019) have shown strong performance gains using self-supervised training that masks individual words or subword units. However, many NLP tasks involve reasoning about relationships between two or more spans of text. For example, in extractive question answering (Rajpurkar et al., 2016), determining that the \u201cDenver Broncos\u201d is a type of \u201cNFL team\u201d is critical for answering the question \u201cWhich NFL team won Super Bowl\n\u2217Equal contribution. 1Our code and pre-trained models are available at\nhttps://github.com/facebookresearch/ SpanBERT. 50?\u201d Such spans provide a more challenging target for self supervision tasks, for example predicting \u201cDenver Broncos\u201d is much harder than predicting only \u201cDenver\u201d when you know the next word is \u201cBroncos\u201d. In this paper, we introduce a span-level pretraining approach that consistently outperforms BERT, with the largest gains on span selection tasks such as question answering and coreference resolution. We present SpanBERT, a pre-training method that is designed to better represent and predict spans of text. Our method differs from BERT in both the masking scheme and the training objectives. First, we mask random contiguous spans, rather than random individual tokens. Second, we introduce a novel span-boundary objective (SBO) so the model learns to predict the entire masked span from the observed tokens at its boundary. Span-based masking forces the model to predict entire spans solely using the context in which they appear. Furthermore, the span-boundary objective encourages the model to store this span-level information at the boundary tokens, which can be easily accessed during the fine-tuning stage. Figure 1 illustrates our approach. To implement SpanBERT, we build on a welltuned replica of BERT, which itself substantially outperforms the original BERT.", "While building on our baseline, we find that pre-training on single segments, instead of two half-length segments with the next sentence prediction (NSP) objective, considerably improves performance on most downstream tasks. Therefore, we add our modifications on top of the tuned single-sequence BERT baseline. Together, our pre-training process yields models that outperform all BERT baselines on a wide\nar X\niv :1\n90 7.\n10 52\n9v 3\n[ cs\n.C L\n] 1\n8 Ja\nn 20\n20\nL(football)", "= LMLM(football) + LSBO(football) <latexit sha1_base64=\"uy6mg7GgWI9pgaWRdjoUT0/lmQk=\">AAACXXicbVHPS8MwGE2r021OnXrw4CU4hIkwWhH0Iox58TBxolNhLSPN0i0sbUryVRyl/6Q3vfivmP046NyDwOO995F8L0EiuAbH+bTstfXCxmaxVN6qbO/sVvf2n7VMFWVdKoVUrwHRTPCYdYGDYK+JYiQKBHsJxjdT/+WNKc1l/ASThPkRGcY85JSAkfpV8CICI0pE1s7rHrB3yEIpISBC5Kf4Gv+y+9ncv2vf5SuyZ6uyj637Fdl+teY0nBnwf+IuSA0t0OlXP7yBpGnEYqCCaN1znQT8jCjgVLC87KWaJYSOyZD1DI1JxLSfzdrJ8YlRBjiUypwY8Ez9PZGRSOtJFJjkdAG97E3FVV4vhfDKz3icpMBiOr8oTAUGiadV4wFXjIKYGEKo4uatmI6IIhTMh5RNCe7yyv/J83nDdRruw0Wt2VrUUURH6BjVkYsuURPdog7qIoq+LGSVrLL1bRfsir0zj9rWYuYA/YF9+AM8t7dx</latexit><latexit sha1_base64=\"uy6mg7GgWI9pgaWRdjoUT0/lmQk=\">AAACXXicbVHPS8MwGE2r021OnXrw4CU4hIkwWhH0Iox58TBxolNhLSPN0i0sbUryVRyl/6Q3vfivmP046NyDwOO995F8L0EiuAbH+bTstfXCxmaxVN6qbO/sVvf2n7VMFWVdKoVUrwHRTPCYdYGDYK+JYiQKBHsJxjdT/+WNKc1l/ASThPkRGcY85JSAkfpV8CICI0pE1s7rHrB3yEIpISBC5Kf4Gv+y+9ncv2vf5SuyZ6uyj637Fdl+teY0nBnwf+IuSA0t0OlXP7yBpGnEYqCCaN1znQT8jCjgVLC87KWaJYSOyZD1DI1JxLSfzdrJ8YlRBjiUypwY8Ez9PZGRSOtJFJjkdAG97E3FVV4vhfDKz3icpMBiOr8oTAUGiadV4wFXjIKYGEKo4uatmI6IIhTMh5RNCe7yyv/J83nDdRruw0Wt2VrUUURH6BjVkYsuURPdog7qIoq+LGSVrLL1bRfsir0zj9rWYuYA/YF9+AM8t7dx</latexit><latexit sha1_base64=\"uy6mg7GgWI9pgaWRdjoUT0/lmQk=\">AAACXXicbVHPS8MwGE2r021OnXrw4CU4hIkwWhH0Iox58TBxolNhLSPN0i0sbUryVRyl/6Q3vfivmP046NyDwOO995F8L0EiuAbH+bTstfXCxmaxVN6qbO/sVvf2n7VMFWVdKoVUrwHRTPCYdYGDYK+JYiQKBHsJxjdT/+WNKc1l/ASThPkRGcY85JSAkfpV8CICI0pE1s7rHrB3yEIpISBC5Kf4Gv+y+9ncv2vf5SuyZ6uyj637Fdl+teY0nBnwf+IuSA0t0OlXP7yBpGnEYqCCaN1znQT8jCjgVLC87KWaJYSOyZD1DI1JxLSfzdrJ8YlRBjiUypwY8Ez9PZGRSOtJFJjkdAG97E3FVV4vhfDKz3icpMBiOr8oTAUGiadV4wFXjIKYGEKo4uatmI6IIhTMh5RNCe7yyv/J83nDdRruw0Wt2VrUUURH6BjVkYsuURPdog7qIoq+LGSVrLL1bRfsir0zj9rWYuYA/YF9+AM8t7dx</latexit><latexit sha1_base64=\"uy6mg7GgWI9pgaWRdjoUT0/lmQk=\">AAACXXicbVHPS8MwGE2r021OnXrw4CU4hIkwWhH0Iox58TBxolNhLSPN0i0sbUryVRyl/6Q3vfivmP046NyDwOO995F8L0EiuAbH+bTstfXCxmaxVN6qbO/sVvf2n7VMFWVdKoVUrwHRTPCYdYGDYK+JYiQKBHsJxjdT/+WNKc1l/ASThPkRGcY85JSAkfpV8CICI0pE1s7rHrB3yEIpISBC5Kf4Gv+y+9ncv2vf5SuyZ6uyj637Fdl+teY0nBnwf+IuSA0t0OlXP7yBpGnEYqCCaN1znQT8jCjgVLC87KWaJYSOyZD1DI1JxLSfzdrJ8YlRBjiUypwY8Ez9PZGRSOtJFJjkdAG97E3FVV4vhfDKz3icpMBiOr8oTAUGiadV4wFXjIKYGEKo4uatmI6IIhTMh5RNCe7yyv/J83nDdRruw0Wt2VrUUURH6BjVkYsuURPdog7qIoq+LGSVrLL1bRfsir0zj9rWYuYA/YF9+AM8t7dx</latexit>\n= log P (football | x7) log P (football | x4,x9,p3)\nvariety of tasks, and reach substantially better performance on span selection tasks in particular.", "Specifically, our method reaches 94.6% and 88.7% F1 on SQuAD 1.1 and 2.0 (Rajpurkar et al., 2016, 2018), respectively \u2014 reducing error by as much as 27% compared to our tuned BERT replica. We also observe similar gains on five additional extractive question answering benchmarks (NewsQA, TriviaQA, SearchQA, HotpotQA, and Natural Questions).2\nSpanBERT also arrives at a new state of the art on the challenging CoNLL-2012 (\u201cOntoNotes\u201d) shared task for document-level coreference resolution, where we reach 79.6% F1, exceeding the previous top model by 6.6% absolute. Finally, we demonstrate that SpanBERT also helps on tasks that do not explicitly involve span selection, and show that our approach even improves performance on TACRED (Zhang et al., 2017) and GLUE (Wang et al., 2019). While others show the benefits of adding more data (Yang et al., 2019) and increasing model size (Lample and Conneau, 2019), this work demonstrates the importance of designing good pretraining tasks and objectives, which can also have a remarkable impact. 2 Background: BERT.\nBERT (Devlin et al., 2019) is a self-supervised approach for pre-training a deep transformer encoder (Vaswani et al., 2017), before fine-tuning\n2We use the modified MRQA version of these datasets. See more details in Section 4.1.\nit for a particular downstream task. BERT optimizes two training objectives \u2013 masked language model (MLM) and next sentence prediction (NSP) \u2013 which only require a large collection of unlabeled text. Notation Given a sequence of word or sub-word tokens X = (x1, x2, . . . , xn), BERT trains an encoder that produces a contextualized vector representation for each token: enc(x1, x2, . . . , xn) = x1,x2, . . . ,xn. Masked Language Model (MLM) Also known as a cloze test, MLM is the task of predicting missing tokens in a sequence from their placeholders. Specifically, a subset of tokens Y \u2286 X is sampled and substituted with a different set of tokens.", "In BERT\u2019s implementation, Y accounts for 15% of the tokens in X; of those, 80% are replaced with [MASK], 10% are replaced with a random token (according to the unigram distribution), and 10% are kept unchanged. The task is to predict the original tokens in Y from the modified input. BERT selects each token in Y independently by randomly selecting a subset. In SpanBERT, we define Y by randomly selecting contiguous spans (Section 3.1). Next Sentence Prediction (NSP) The NSP task takes two sequences (XA, XB) as input, and predicts whetherXB is the direct continuation ofXA. This is implemented in BERT by first reading XA from the corpus, and then (1) either reading XB from the point where XA ended, or (2) randomly sampling XB from a different point in the cor-\npus. The two sequences are separated by a special [SEP]token. Additionally, a special [CLS]token is added to XA, XB to form the input, where the target of [CLS]is whetherXB indeed followsXA in the corpus. In summary, BERT optimizes the MLM and the NSP objectives by masking word pieces uniformly at random in data generated by the bisequence sampling procedure. In the next section, we will present our modifications to the data pipeline, masking, and pre-training objectives. 3 Model. We present SpanBERT, a self-supervised pretraining method designed to better represent and predict spans of text. Our approach is inspired by BERT (Devlin et al., 2019), but deviates from its bi-text classification framework in three ways. First, we use a different random process to mask spans of tokens, rather than individual ones. We also introduce a novel auxiliary objective \u2013 the span boundary objective (SBO) \u2013 which tries to predict the entire masked span using only the representations of the tokens at the span\u2019s boundary. Finally, SpanBERT samples a single contiguous segment of text for each training example (instead of two), and thus does not use BERT\u2019s next sentence prediction objective, which we omit. 3.1 Span Masking.", "Given a sequence of tokensX = (x1, x2, . . . , xn), we select a subset of tokens Y \u2286 X by iteratively sampling spans of text until the masking budget (e.g. 15% of X) has been spent. At each iteration, we first sample a span length (number of words) from a geometric distribution ` \u223c Geo(p), which is skewed towards shorter spans. We then randomly (uniformly) select the starting point for the span to be masked. We always sample a sequence of complete words (instead of subword tokens) and the starting point must be the beginning of one word. Following preliminary trials3, we set p = 0.2, and also clip ` at `max = 10. This yields a mean span length of mean(`) = 3.8. Figure 2 shows the distribution of span mask lengths. As in BERT, we also mask 15% of the tokens in total: replacing 80% of the masked tokens with [MASK], 10% with random tokens and 10% with the original tokens. However, we perform this re-\n3We experimented with p = {0.1, 0.2, 0.4} and found 0.2 to perform the best.\nplacement at the span level and not for each token individually; i.e. all the tokens in a span are replaced with [MASK]or sampled tokens. 3.2 Span Boundary Objective (SBO). Span selection models (Lee et al., 2016, 2017; He et al., 2018) typically create a fixed-length representation of a span using its boundary tokens (start and end). To support such models, we would ideally like the representations for the end of the span to summarize as much of the internal span content as possible. We do so by introducing a span boundary objective that involves predicting each token of a masked span using only the representations of the observed tokens at the boundaries (Figure 1). Formally, we denote the output of the transformer encoder for each token in the sequence by x1, . . . ,xn. Given a masked span of tokens (xs, . . .", ", xe) \u2208 Y , where (s, e) indicates its start and end positions, we represent each token xi in the span using the output encodings of the external boundary tokens xs\u22121 and xe+1, as well as the position embedding of the target token pi\u2212s+1:\nyi = f(xs\u22121,xe+1,pi\u2212s+1)\nwhere position embeddings p1,p2, . . . mark relative positions of the masked tokens with respect to the left boundary token xs\u22121. We implement the representation function f(\u00b7) as a 2- layer feed-forward network with GeLU activations (Hendrycks and Gimpel, 2016) and layer normal-\nization (Ba et al., 2016):\nh0 = [xs\u22121;xe+1;pi\u2212s+1]\nh1 = LayerNorm(GeLU(W1h0)) yi = LayerNorm(GeLU(W2h1)) We then use the vector representation yi to predict the token xi and compute the cross-entropy loss exactly like the MLM objective. SpanBERT sums the loss from both the span boundary and the regular masked language model objectives for each token xi in the masked span (xs, ..., xe), while reusing the input embedding (Press and Wolf, 2017) for the target tokens in both MLM and SBO:\nL(xi) = LMLM(xi) + LSBO(xi) = \u2212 logP (xi | xi)\u2212 logP (xi | yi)\n3.3 Single-Sequence Training. As described in Section 2, BERT\u2019s examples contain two sequences of text (XA, XB), and an objective that trains the model to predict whether they are connected (NSP). We find that this setting is almost always worse than simply using a single sequence without the NSP objective (see Section 5 for further details). We conjecture that single-sequence training is superior to bi-sequence training with NSP because (a) the model benefits from longer full-length contexts, or (b) conditioning on, often unrelated, context from another document adds noise to the masked language model. Therefore, in our approach, we remove both the NSP objective and the two-segment sampling procedure, and simply sample a single contiguous segment of up to n = 512 tokens, rather than two half-segments that sum up to n tokens together.", "In summary, SpanBERT pre-trains span representations by: (1) masking spans of full words using a geometric distribution based masking scheme (Section 3.1), (2) optimizing an auxiliary span-boundary objective (Section 3.2) in addition to MLM using a single-sequence data pipeline (Section 3.3). A procedural description can be found in Appendix A.\n4 Experimental Setup.\n4.1 Tasks. We evaluate on a comprehensive suite of tasks, including seven question answering tasks, corefer-\nence resolution, nine tasks in the GLUE benchmark (Wang et al., 2019), and relation extraction. We expect that the span selection tasks, question answering and coreference resolution, will particularly benefit from our span-based pre-training. Extractive Question Answering Given a short passage of text and a question as input, the task of extractive question answering is to select a contiguous span of text in the passage as the answer. We first evaluate on SQuAD 1.1 and 2.0 (Rajpurkar et al., 2016, 2018), which have served as major question answering benchmarks, particularly for pre-trained models (Peters et al., 2018; Devlin et al., 2019; Yang et al., 2019). We also evaluate on five more datasets from the MRQA shared task (Fisch et al., 2019)4: NewsQA (Trischler et al., 2017), SearchQA (Dunn et al., 2017), TriviaQA (Joshi et al., 2017), HotpotQA (Yang et al., 2018) and Natural Questions (Kwiatkowski et al., 2019). Because the MRQA shared task does not have a public test set, we split the development set in half to make new development and test sets. The datasets vary in both domain and collection methodology, making this collection a good testbed for evaluating whether our pre-trained models can generalize well across different data distributions. Following BERT (Devlin et al., 2019), we use the same QA model architecture for all the datasets. We first convert the passage P = (p1, p2, . . . , pl) and question Q = (q1, q2, . . . , ql\u2032) into a single sequence X = [CLS]p1p2 . . . pl[SEP]q1q2 . . .", "ql\u2032[SEP], pass it to the pre-trained transformer encoder, and train two linear classifiers independently on top of it for predicting the answer span boundary (start and end). For the unanswerable questions in SQuAD 2.0, we simply set the answer span to be the special token [CLS]for both training and testing. Coreference Resolution Coreference resolution is the task of clustering mentions in text which refer to the same real-world entities. We evaluate on the CoNLL-2012 shared task (Pradhan et al., 2012) for document-level coreference resolution. We use the independent version of the Joshi et al. (2019b) implementation of the higher-order coref-\n4https://github.com/mrqa/MRQA-Shared-Task-2019. MRQA changed the original datasets to unify them into the same format, e.g. all the contexts are truncated to a maximum of 800 tokens and only answerable questions are kept.\nerence model (Lee et al., 2018). The document is divided into non-overlapping segments of a predefined length.5 Each segment is encoded independently by the pre-trained transformer encoder, which replaces the original LSTM-based encoder. For each mention span x, the model learns a distribution P (\u00b7) over possible antecedent spans Y :\nP (y) = es(x,y)\u2211\ny\u2032\u2208Y e s(x,y\u2032) The span pair scoring function s(x, y) is a feedforward neural network over fixed-length span representations and hand-engineered features over x and y:\ns(x, y) = sm(x) + sm(y) + sc(x, y)\nsm(x) = FFNNm(gx)\nsc(x, y) = FFNNc(gx,gy, \u03c6(x, y)) Here gx and gy denote the span representations, which are a concatenation of the two transformer output states of the span endpoints and an attention vector computed over the output representations of the token in the span. FFNNm and FFNNc represent two feedforward neural networks with one hidden layer, and \u03c6(x, y) represents the handengineered features (e.g. speaker and genre information). A more detailed description of the model can be found in Joshi et al. (2019b).", "Relation Extraction TACRED (Zhang et al., 2017) is a challenging relation extraction dataset. Given one sentence and two spans within it \u2013 subject and object \u2013 the task is to predict the relation between the spans from 42 pre-defined relation types, including no_relation. We follow the entity masking schema from Zhang et al. (2017) and replace the subject and object entities by their NER tags such as \u201c[CLS][SUBJ-PER] was born in [OBJ-LOC] , Michigan, . . . \u201d, and finally add a linear classifier on top of the [CLS]token to predict the relation type. GLUE The General Language Understanding Evaluation (GLUE) benchmark (Wang et al., 2019) consists of 9 sentence-level classification tasks: \u2022 Two sentence-level classification tasks including CoLA (Warstadt et al., 2018) for\n5The length was chosen from {128, 256, 384, 512}. See more details in Appendix B.\nevaluating linguistic acceptability and SST-2 (Socher et al., 2013) for sentiment classification. \u2022 Three sentence-pair similarity tasks including MRPC (Dolan and Brockett, 2005), a binary paraphrasing task sentence pairs from news sources, STS-B (Cer et al., 2017), a graded similarity task for news headlines, and QQP6, a binary paraphrasing tasking between Quora question pairs. \u2022 Four natural language inference tasks including MNLI (Williams et al., 2018), QNLI (Rajpurkar et al., 2016), RTE (Dagan et al., 2005; Bar-Haim et al., 2006; Giampiccolo et al., 2007) and WNLI (Levesque et al., 2011). Unlike question answering, coreference resolution, and relation extraction, these sentence-level tasks do not require explicit modeling of spanlevel semantics. However, they might still benefit from implicit span-based reasoning (e.g., the Prime Minister is the head of the government). Following previous work (Devlin et al., 2019; Radford et al., 2018)7, we exclude WNLI from the results to enable a fair comparison.", "While recent work Liu et al. (2019a) has applied several taskspecific strategies to increase performance on the individual GLUE tasks, we follow BERT\u2019s singletask setting and only add a linear classifier on top of the [CLS]token for these classification tasks. 4.2 Implementation. We reimplemented BERT\u2019s model and pretraining method in fairseq (Ott et al., 2019). We used the model configuration of BERTlarge as in Devlin et al. (2019) and also pre-trained all our models on the same corpus: BooksCorpus and English Wikipedia using cased Wordpiece tokens. Compared to the original BERT implementation, the main differences in our implementation include: (a) We use different masks at each epoch while BERT samples 10 different masks for each sequence during data processing. (b) We remove all the short-sequence strategies used before (they sampled shorter sequences with a small probability 0.1; they also first pre-trained with smaller se-\n6https://data.quora.com/First-Quora-Dataset-ReleaseQuestion-Pairs\n7Previous work has excluded WNLI on account of construction issues outlined on the GLUE website \u2013 https: //gluebenchmark.com/faq\nquence length of 128 for 90% of the steps). Instead, we always take sequences of up to 512 tokens until it reaches a document boundary. We refer readers to Liu et al. (2019b) for further discussion on these modifications and their effects. As in BERT, the learning rate is warmed up over the first 10,000 steps to a peak value of 1e-4, and then linearly decayed. We retain \u03b2 hyperparameters (\u03b21 = 0.9, \u03b22 = 0.999) and a decoupled weight decay (Loshchilov and Hutter, 2019) of 0.1. We also keep a dropout of 0.1 on all layers and attention weights, and a GeLU activation function (Hendrycks and Gimpel, 2016). We deviate from the optimization by running for 2.4M steps and using an epsilon of 1e-8 for AdamW (Kingma and Ba, 2015), which converges to a better set of model parameters.", "Our implementation uses a batch size of 256 sequences with a maximum of 512 tokens.8 For the SBO, we use 200 dimension position embeddings p1,p2, . . . to mark positions relative to the left boundary token. The pre-training was done on 32 Volta V100 GPUs and took 15 days to complete. Fine-tuning is implemented based on HuggingFace\u2019s codebase (Wolf et al., 2019) and more details are given in Appendix B.\n4.3 Baselines. We compare SpanBERT to three baselines:\nGoogle BERT The pre-trained models released by Devlin et al. (2019).9\nOur BERT Our reimplementation of BERT with improved data preprocessing and optimization (Section 4.2). Our BERT-1seq Our reimplementation of BERT trained on single full-length sequences without NSP (Section 3.3). 5 Results. We compare SpanBERT to the baselines per task, and draw conclusions based on the overall trends. 5.1 Per-Task Results. Extractive Question Answering Table 1 shows the performance on both SQuAD 1.1 and 2.0. SpanBERT exceeds our BERT baseline by 2.0% and 2.8% F1 respectively (3.3% and 5.4% over\n8On the average, this is approximately 390 sequences since some documents have fewer than 512 tokens\n9https://github.com/google-research/bert. Google BERT). In SQuAD 1.1, this result accounts for over 27% error reduction, reaching 3.4% F1 above human performance. Table 2 demonstrates that this trend goes beyond SQuAD, and is consistent in every MRQA dataset. On average, we see a 2.9% F1 improvement from our reimplementation of BERT. Although some gains are coming from singlesequence training (+1.1%), most of the improvement stems from span masking and the span boundary objective (+1.8%), with particularly large gains on TriviaQA (+3.2%) and HotpotQA (+2.7%). Coreference Resolution Table 3 shows the performance on the OntoNotes coreference resolution benchmark. Our BERT reimplementation improves the Google BERT model by 1.2% on the average F1 metric and single-sequence training brings another 0.5% gain.", "Finally, SpanBERT improves considerably on top of that, achieving a new state of the art of 79.6% F1 (previous best result is 73.0%). Relation Extraction Table 4 shows the performance on TACRED. SpanBERT exceeds our reimplementation of BERT by 3.3% F1 and achieves close to the current state of the art (Soares et al., 2019) \u2014 Our model performs better than their BERTEM but is 0.7 point behind BERTEM + MTB which used entity-linked text for additional pre-training. Most of this gain (+2.6%) stems from single-sequence training although the contribution of span masking and the span boundary objective is still a considerable 0.7%, resulting largely from higher recall. GLUE Table 5 shows the performance on GLUE. For most tasks, the different models appear to perform similarly. Moving to singlesequence training without the NSP objective substantially improves CoLA, and yields smaller\n(but considerable) improvements on MRPC and MNLI. The main gains from SpanBERT are in the SQuAD-based QNLI dataset (+1.3%) and in RTE (+6.9%), the latter accounting for most of the rise in SpanBERT\u2019s GLUE average. 5.2 Overall Trends. We compared our approach to three BERT baselines on 17 benchmarks, and found that SpanBERT outperforms BERT on almost every task. In 14 tasks, SpanBERT performed better than all baselines. In 2 tasks (MRPC and QQP), it performed on-par in terms of accuracy with singlesequence trained BERT, but still outperformed the other baselines. In one task (SST-2), Google\u2019s BERT baseline performed better than SpanBERT by 0.4% accuracy. When considering the magnitude of the gains, it appears that SpanBERT is especially better at extractive question answering. In SQuAD 1.1, for example, we observe a solid gain of 2.0% F1 even though the baseline is already well above human performance. On MRQA, SpanBERT improves between 2.0% (Natural Questions) and 4.6% (TriviaQA) F1 on top of our BERT baseline.", "Finally, we observe that single-sequence training works considerably better than bi-sequence training with next sentence prediction (NSP) with BERT\u2019s choice of sequence lengths for a wide variety of tasks . This is surprising because BERT\u2019s ablations showed gains from the NSP objective (Devlin et al., 2019). However, the ablation studies still involved bi-sequence data processing, i.e. the pre-training stage only controlled for the NSP objective while still sampling two half-length sequences. We hypothesize that bisequence training, as it is implemented in BERT (see Section 2), impedes the model from learning longer-range features, and consequently hurts performance on many downstream tasks. 6 Ablation Studies. We compare our random span masking scheme with linguistically-informed masking schemes, and find that masking random spans is a competitive and often better approach. We then study the impact of the span boundary objective (SBO), and contrast it with BERT\u2019s next sentence prediction\n(NSP) objective.10\n6.1 Masking Schemes. Previous work (Sun et al., 2019) has shown improvements in downstream task performance by masking linguistically-informed spans during pre-training for Chinese data. We compare our random span masking scheme with masking of linguistically-informed spans. Specifically, we train the following five baseline models differing only in the way tokens are masked. Subword Tokens We sample random Wordpiece tokens, as in the original BERT. Whole Words We sample random words, and then mask all of the subword tokens in those words. The total number of masked subtokens is around 15%. Named Entities At 50% of the time, we sample from named entities in the text, and sample random whole words for the other 50%. The total\n10To save time and resources, we use the checkpoints at 1.2M steps for all the ablation experiments. number of masked subtokens is 15%.", "Specifically, we run spaCy\u2019s named entity recognizer11 on the corpus and select all the non-numerical named entity mentions as candidates. Noun Phrases Similar as Named Entities, we sample from noun phrases at 50% of the time. The noun phrases are extracted by running spaCy\u2019s constituency parser. Geometric Spans We sample random spans from a geometric distribution, as in our SpanBERT (see Section 3.1). Table 6 shows how different pre-training masking schemes affect performance on the development set of a selection of tasks. All the models are evaluated on the development sets and are based on the default BERT setup of bi-sequence training with NSP; the results are not directly comparable to the main evaluation. With the exception of coreference resolution, masking random spans is preferable to other strategies. Although linguistic masking schemes (named entities and\n11https://spacy.io/\nnoun phrases) are often competitive with random spans, their performance is not consistent; for instance, masking noun phrases achieves parity with random spans on NewsQA, but underperforms on TriviaQA (-1.1% F1). On coreference resolution, we see that masking random subword tokens is preferable to any form of span masking. Nevertheless, we shall see in the following experiment that combining random span masking with the span boundary objective can improve upon this result considerably. 6.2 Auxiliary Objectives. In Section 5, we saw that bi-sequence training with the next sentence prediction (NSP) objective can hurt performance on downstream tasks, when compared to single-sequence training. We test whether this holds true for models pre-trained with span masking, and also evaluate the effect of replacing the NSP objective with the span boundary objective (SBO). Table 7 confirms that single-sequence training typically improves performance. Adding SBO further improves performance, with a substantial gain on coreference resolution (+2.7% F1) over span masking alone.", "Unlike the NSP objective, SBO does not appear to have any adverse effects. 7 Related Work. Pre-trained contextualized word representations that can be trained from unlabeled text (Dai and Le, 2015; Melamud et al., 2016; Peters et al., 2018) have had immense impact on NLP lately, particularly as methods for initializing a large model before fine-tuning it for a specific task (Howard and Ruder, 2018; Radford et al., 2018; Devlin et al., 2019). Beyond differences in model hyperparameters and corpora, these methods mainly differ in their pre-training tasks and loss functions, with a considerable amount of contemporary literature proposing augmentations of BERT\u2019s masked language modeling (MLM) objective. While previous and concurrent work has looked at masking (Sun et al., 2019) or dropping (Song et al., 2019; Chan et al., 2019) multiple words from the input \u2013 particularly as pretraining for language generation tasks \u2013 SpanBERT pretrains span representations (Lee et al., 2016), which are widely used for question answering, coreference resolution and a variety of other tasks. ERNIE\n(Sun et al., 2019) shows improvements on Chinese NLP tasks using phrase and named entity masking. MASS (Song et al., 2019) focuses on language generation tasks, and adopts the encoderdecoder framework to reconstruct a sentence fragment given the remaining part of the sentence. We attempt to more explicitly model spans using the SBO objective, and show that (geometrically distributed) random span masking works as well, and sometimes better than, masking linguisticallycoherent spans. We evaluate on English benchmarks for question answering, relation extraction, and coreference resolution in addition to GLUE. A different ERNIE (Zhang et al., 2019) focuses on integrating structured knowledge bases with contextualized representations with an eye on knowledge-driven tasks like entity typing and relation classification.", "UNILM (Dong et al., 2019) uses multiple language modeling objectives \u2013 unidirectional (both left-to-right and right-to-left), bidirectional, and sequence-to-sequence prediction \u2013 to aid generation tasks like summarization and question generation. XLM (Lample and Conneau, 2019) explores cross-lingual pre-training for multilingual tasks such as translation and crosslingual classification. Kermit (Chan et al., 2019), an insertion based approach, fills in missing tokens (instead of predicting masked ones) during pretraining; they show improvements on machine translation and zero-shot question answering. Concurrent with our work, RoBERTa (Liu et al., 2019b) presents a replication study of BERT pre-training that measures the impact of many key hyperparameters and training data size. Also concurrent, XLNet (Yang et al., 2019) combines an autoregressive loss and the Transformer-XL (Dai et al., 2019) architecture with a more than an eight-fold increase in data to achieve current stateof-the-art results on multiple benchmarks. XLNet also masks spans (of 1-5 tokens) during pretraining, but predicts them autoregressively. Our model focuses on incorporating span-based pretraining, and as a side effect, we present a stronger BERT baseline while controlling for the corpus, architecture, and the number of parameters. Related to our SBO objective, pair2vec (Joshi et al., 2019a) encodes word-pair relations using a negative sampling-based multivariate objective during pre-training. Later, the word-pair representations are injected into the attention-layer of downstream tasks, and thus encode limited down-\nstream context. Unlike pair2vec, our SBO objective yields \u201cpair\u201d (start and end tokens of spans) representations which more fully encode the context during both pre-training and finetuning, and are thus more appropriately viewed as span representations. Stern et al.", "(2018) focus on improving language generation speed using a block-wise parallel decoding scheme; they make predictions for multiple time steps in parallel and then back off to the longest prefix validated by a scoring model. Also related are sentence representation methods (Kiros et al., 2015; Logeswaran and Lee, 2018) which focus on predicting surrounding contexts from sentence embeddings. 8 Conclusion. We presented a new method for span-based pretraining which extends BERT by (1) masking contiguous random spans, rather than random tokens, and (2) training the span boundary representations to predict the entire content of the masked span, without relying on the individual token representations within it. Together, our pre-training process yields models that outperform all BERT baselines on a variety of tasks, and reach substantially better performance on span selection tasks in particular.\nAcknowledgements. We would like to thank Pranav Rajpurkar and Robin Jia for patiently helping us evaluate SpanBERT on SQuAD. We thank the anonymous reviewers, the action editor, and our colleagues at Facebook AI Research and the University of Washington for their insightful feedback that helped improve the paper. A Pre-training Procedure. We describe our pre-training procedure as follows:\n1. Divide the corpus into single contiguous blocks of up to 512 tokens. 2. At each step of pre-training:\n(a) Sample a batch of blocks uniformly at random. (b) Mask 15% of word pieces in each block in the batch using the span masking scheme (Section 3.1). (c) For each masked token xi, optimize L(xi) = LMLM(xi) + LSBO(xi) (Section 3.2). B Fine-tuning Hyperparameters. We apply the following fine-tuning hyperparameters to all methods, including the baselines. Extractive Question Answering For all the question answering tasks, we use max_seq_length = 512 and a sliding window of size 128 if the lengths are longer than 512.", "We choose learning rates from {5e-6, 1e-5, 2e-5, 3e-5, 5e-5} and batch sizes from {16, 32} and fine-tune 4 epochs for all the datasets. Coreference Resolution We divide the documents into multiple chunks of lengths up to max_seq_length and encode each chunk independently. We choose max_seq_length from {128, 256, 384, 512}, BERT learning rates from {1e-5, 2e-5}, task-specific learning rates from {1e-4, 2e-4, 3e-4} and fine-tune 20 epochs for all the datasets. We use batch size = 1 (one document) for all the experiments. TACRED/GLUE We use max_seq_length = 128 and choose learning rates from {5e-6, 1e5, 2e-5, 3e-5, 5e-5} and batch sizes from {16, 32} and fine-tuning 10 epochs for all the datasets. The only exception is CoLA, where we used 4 epochs (following Devlin et al. (2019)), because 10 epochs lead to severe overfitting."]}